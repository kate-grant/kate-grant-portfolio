{"componentChunkName":"component---src-templates-post-template-js","path":"/new-react-documentation-2023/","result":{"data":{"site":{"siteMetadata":{"title":"Kate Grant - Software Engineer"}},"markdownRemark":{"id":"258eed50-091c-55bd-adab-7824ca2cafe4","excerpt":"React.js, the popular JavaScript library for building user interfaces, has recently launched a new website, react.dev, which provides updated documentation andâ€¦","html":"<p>React.js, the popular JavaScript library for building user interfaces, has recently launched a new website, <a href=\"http://react.dev\" title=\"react.dev\">react.dev</a>, which provides updated documentation and resources for the latest version of React. The website has been designed to help developers learn modern React using <a href=\"https://react.dev/learn#:~:text=A%20component%20is%20a%20piece%20of%20the%20UI%20(user%20interface)%20that%20has%20its%20own%20logic%20and%20appearance.\">Function components</a> and <a href=\"https://react.dev/learn/thinking-in-react#:~:text=Hooks%20are%20special%20functions%20that%20let%20you%20%E2%80%9CHook%20into%E2%80%9D%20React\">Hooks</a>, with over 600 interactive examples, diagrams, illustrations, and challenges. (The previous React documentation site has now been archived at <a href=\"http://legacy.reactjs.org\" title=\"legacy.reactjs.org\">legacy.reactjs.org</a>). The changes are intended to provide a more engaging and effective learning experience for developers.</p>\n<p>One of the key changes is that the new documentation now teaches React with Hooks <em>\"from the beginning\"</em>, rather than assuming readers are familiar with Class components. This approach aims to make it easier for developer new to the framework to learn React without having to learn it twice--first to gain context for recent changes and again to learn the latest design patterns. However, there are still some rare Class component use cases that do not have a Hook-based equivalent, and Class components remain supported and are documented in the Legacy API section of the new site.</p>\n<p>The new site includes a self-paced course called <a href=\"https://react.dev/learn\" title=\"Learn React\">Learn React</a> that teaches React from scratch, with chapters covering the fundamentals of React, adding interactivity, managing state, and using Hooks. There is also an <a href=\"https://react.dev/reference/react\" title=\"API Reference\">API Reference</a> section that provides details and usage examples for every React API.</p>\n<p>One of the standout features of the new site is the use of over 600 interactive examples throughout the site. The examples are provided in sandboxes, which can be edited, forked, and opened in a separate tab, allowing users to play with the React APIs and explore their own ideas.</p>\n<p>The new React site has a modern look and feel and is designed to provide an engaging and participatory learning experience. However, some developers may find it challenging to adapt to the new approach, especially those who are accustomed to using Class components in React. Additionally, the transition to the new site and the separation of legacy content may cause confusion for new users googling for documentation without enough context about the version they are working with.</p>\n<h2>React Class Components vs Function Components</h2>\n<p>In the earlier days of React, Class components were the primary way of building components. However, with the release of React 16.8 in 2019, React introduced a new feature called Hooks, which made it possible to use state and other React features in Function components. This led to a significant shift in how developers build React applications, and Function components have become the preferred way of building components in modern React applications.</p>\n<p>Function components are simpler and easier to understand than Class components. They are just plain JavaScript functions that return a piece of JSX. Function components also make it easy to write reusable code since they are more modular than Class components. In addition, Function components are faster to execute than Class components since they don't carry the overhead of the React component lifecycle.</p>\n<p>Another significant benefit of Function components over Class components is that they don't have their own <code>this</code> context. This means that they don't require the binding of <code>this</code> in the constructor or in event handlers. In Class components, <code>this</code> refers to the instance of the component, which can cause confusion and introduce bugs if not handled properly.</p>\n<blockquote>\n<ul>\n<li>Function components are just plain JavaScript functions that return a piece of JSX.</li>\n</ul>\n</blockquote>\n<h3>Benefits of Function Components</h3>\n<p><strong>Simplicity:</strong> Function components are simpler to write and understand than Class components. They are just plain JavaScript functions that return JSX, and there is no need to worry about <code>this</code> or <code>bind</code>.</p>\n<p><strong>Performance:</strong> Function components are typically faster than Class components because they have a smaller overhead. This is because they don't have any state or lifecycle methods, and don't need to create an instance of the component class.</p>\n<p><strong>Easier Testing:</strong> Function components are easier to test than Class components because they don't have any state or lifecycle methods that need to be mocked up when considering unit test design.</p>\n<h3>Functional Programming and React Function Components</h3>\n<h4>Function components as Pure Functions</h4>\n<p>The use of Function components in React is also related to the functional programming paradigm. Functional programming is a programming paradigm that emphasizes the use of pure functions and immutable data structures. In React, Function components can be thought of as pure functions that take in props as input and return JSX as output, because for any prop value input will yield consistent JSX.</p>\n<p>By using Function components, we can embrace the functional programming paradigm and write more declarative, composable, and testable code. We can also take advantage of React Hooks, which are functions that allow us to use state and other React features in Function components without needing to use classes. To some in the functional community, the change of state may be considered a side effect, but consise and consistent purity of Function components are still a welcome improvement to React design patterns.</p>\n<p>Overall, the shift from Class components to Function components in React aligns with a broader trend towards functional programming in the JavaScript community, and can lead to simpler, more performant, and more testable code.</p>\n<blockquote>\n<ul>\n<li>Function components can be thought of as pure functions that take in props as input and return JSX as output.</li>\n</ul>\n</blockquote>\n<h4>Is JavaScript a Functional Language?</h4>\n<p>Not quite--although JavaScript is definitely capable of providing some of the benefits of functional programming when written with functional design patterns in mind. It's possible to argue that JavaScript is <strong>both</strong> a functional language (FP) and an object-oriented language (OOP).</p>\n<p>To illustrate the spectrum of how the label <em>\"functional language\"</em> is applied, let's consider a <em>\"purely functional\"</em> language, Haskell. Haskell is a language where functions are always pure by default, meaning they don't change external things like global variables or mutable data structures, and always return the same output for the same input. This makes it easier to understand how functions behave and can lead to fewer bugs.</p>\n<p>On the other hand, Clojure, which is widely-recognized as a functional language, allows side effects and mutable data structures, but it also has a lot of tools that support functional programming concepts like using immutable data structures and higher-order functions. This makes it easier to write code that is modular and less likely to break.</p>\n<p>A key difference between Haskell and Clojure is that Haskell is <strong>statically-typed</strong>, while Clojure is <strong>dynamically-typed</strong>. We will get into the nitty-gritty of <strong>types</strong> in a future blog post, but for now think about it like this:</p>\n<blockquote>\n<p><strong>Uncaught TypeError yourFunction is not a function</strong></p>\n<p>The error above tells you that there is a mismatch between what <code>yourFunction</code> is and how <code>yourFunction</code> is being used.</p>\n<p><code>yourFunction</code> is being called as a function somewhere in your code, but the language does not recognize it as a function because it does not meet the language's set of guidelines for what a function is, or how a function's <strong>\"type\"</strong> is defined. (In this case, these guidelines are baked into the language as part of its implementation for <code>function</code>.)</p>\n<p>Languages that perform type checking at compile time are considered <strong>statically-typed</strong> and will error type mismatches before runtime. Languages that perform type checking at runtime are considered <strong>dynamically-typed</strong> and will error at runtime.</p>\n</blockquote>\n<p>JavaScript is a <strong>dynamically-typed</strong> language. Specifically, the JavaScript interpreter assigns types at runtime and the error above would be seen after executing the program. This means that the program executed--<em>but with errors</em>. A <strong>statically-typed</strong> language errors during compilation and will not execute if there are type errors. The latter provides a safeguard by ensuring that a program that executes has met a certain threshold of analysis, the variables are being utilized in a way that is technically correct. If this sounds like an appealing feature, you may be interested in TypeScript, a superset of JavaScript that provides static-typing.</p>\n<p>JavaScript may not be designed to be purely functional, but as a highly flexibly language it is possible to apply functional concepts in JavaScript with the goal of limiting side effects. Like the functional language Clojure, JavaScript is <strong>dynamically-typed</strong>, but unlike Clojure, JavaScript widely allows for mutability. TypeScript provides more tools that support functional paradigms with JavaScript syntax, including static-typing and options for read-only variables. Haskell is a languages that is built with static-typing and immutability as core features.</p>\n<p>React is a JavaScript framework written in and for JavaScript (and compatible with TypeScript), but is not in and of itself \"functional\". Simply, recent changes and recommendations in the React documentation reflect functional programming design patterns that have become increasingly popular among JavaScript developers.</p>\n<h2>Conclusion</h2>\n<p>In summary, React Class components and Function components are two different ways of defining React components, but Function components are the standard design pattern in React moving forward. Class components are defined using ES6 classes and provide a more traditional object-oriented programming (OOP) approach to building React components. Function components, on the other hand, are defined using JavaScript functions and are a more functional programming (FP) approach to building React components.</p>\n<h3>To migrate from Class components to Function components, developers need to do the following:</h3>\n<h4>Let's start with the following Class component:</h4>\n<pre><code>class Album extends React.Component {\n  constructor(title, artist, tracks) {\n    super();\n    this.state = {\n      title: title,\n      artist: artist,\n      songs: songs\n      };\n  }\n  render() {\n    return &#x3C;p>The album {this.title} by {this.artist} has been created!&#x3C;/p>;\n  }\n}\n</code></pre>\n<ol>\n<li>Convert the Class component to a Function component by changing the class declaration to a function declaration.</li>\n</ol>\n<pre><code>const Album = (title, artist, tracks) => {\n...\n</code></pre>\n<ol start=\"2\">\n<li>Remove the render() method and move its return statement into the function body.</li>\n</ol>\n<pre><code>const Album = (title, artist, tracks) => {\n...\n  return {\n   &#x3C;p>The album {this.title} by {this.artist} has been created!&#x3C;/p>;\n  }\n}\n</code></pre>\n<ol start=\"3\">\n<li>Replace the instance variables (this.state and this.props) with regular function arguments.</li>\n</ol>\n<pre><code>const Album = (title, artist, tracks) => {\n  const [albumTitle, setAlbumTitle] = useState(title);\n  const [albumArtist, setAlbumArtist] = useState(artist);\n  const [albumTracks, setAlbumTracks] = useState(tracks);\n\n  return {\n   &#x3C;p>The album {albumTitle} by {albumArtist} has been created!&#x3C;/p>;\n  }\n}\n</code></pre>\n<p>If your component uses lifecycle methods (componentDidMount(), componentDidUpdate(), etc.), these will need to be replaced with the useEffect Hook. I will cover this in the next blog post.</p>","frontmatter":{"title":"New React Documentation: An Overview of New Documentation and Design Patterns (2023)","date":"April 07, 2023","description":"Learn about changes to the React 18 documentation and new education features."}},"previous":null,"next":null},"pageContext":{"id":"258eed50-091c-55bd-adab-7824ca2cafe4","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}